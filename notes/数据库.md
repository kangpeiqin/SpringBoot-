<p> <a href="../README.md">返回首页</a></p>

# MySQL
# Redis
## 数据结构
字符串(strings)、散列(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)
## 常用命令
可以参考：http://www.redis.cn/commands/append.html
几个常用命令解释：
- `SETEX`:设置key在给定的seconds时间之后超时过期，等效命令(SET、EXPIRE组合)
- `SETNX`(SET if Not exists):如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做
## 持久化
## 缓存设计
缓存可以有效加速应用读写速度(缓存通常都是全内存的(例如:Redis、`Memcache`)，而
存储层查询或者存储会进行I/O操作(例如`MySQL`))，降低后端负载。
![cache 缓存](../asset/cache.jpg)
### 使用场景
- 1、开销大的复杂计算：一些复杂的操作或者计算（例如大量联表操作、一些分组计算），如果不加缓存，不但无法满足高并发量，同时也会给MySQL带来巨大的负担。
- 2、加速请求响应：如果是高并发场景，有些热点数据需要放到缓存当中，防止经常到数据查询进行IO操作，影响性能
### 缓存更新策略
缓存中的数据会和数据源中的真实数据有一段时间窗口的不一致，需要利用某些策略进行更新
- 1、LRU/LFU/FIFO算法剔除：缓存使用量超过了预设的最大空间，如何对现有的数据进行剔除
- 2、超时剔除：通过给缓存数据设置过期时间。超时剔除通过给缓存数据设置过期时间。一段时间窗口内（取决于过期时间长短）存在一致性问题
- 3、主动更新：应用方对于数据的一致性要求高，需要在真实数据更新后，立即更新缓存数据
### 缓存穿透
查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。
导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义
#### 解决方案
- 缓存空对象：当存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源(可以针对这类数据设置一个较短的过期时间，让其自动剔除)
- 布隆过滤器