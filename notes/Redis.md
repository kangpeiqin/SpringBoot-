<p> <a href="../README.md">返回首页</a></p>

# Redis
## 使用场景
缓存、排行榜、消息队列、计数器(文章、视频浏览数根据浏览实时+1,避免频繁的进行IO)
## 架构
使用单线程架构和I/O多路复用模型。每一条命令从客户端达到服务端不会立刻被执行，所有命令都会进入一个队列，然后逐个被执行
### 使用单线程还快速的原因
- 纯内存访问
- 非阻塞IO
- 单线程避免了多线程上下文切换产生的消耗
## 数据结构
字符串(strings)、散列(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)
## 常用命令
可以参考：http://www.redis.cn/commands/append.html
> 几个常用命令解释：
- `SETEX`:设置key在给定的seconds时间之后超时过期，等效命令(SET、EXPIRE组合)
- `SETNX`(SET if Not exists):如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做
## 持久化
Redis其将所有数据都存储在了内存中，一旦宕机或者重启，数据就会丢失，所以需要将数据从内存中同步到硬盘中，这一过程就是持久化。
当下次重启时利用之前持久化的文件即可实现数据恢复。
#### RDB
RDB持久化是把当前进程数据生成快照保存到硬盘的过程，**代表Redis在某个时间点上的数据快照**。触发RDB持久化过程分为手动触发和自动触发。 
当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上。进行快照的条件可以由用户在配置文件中自定义，
由两个参数构成：时间和改动的键的个数。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。
- 优缺点
> - 优点：适用于备份，全量复制等场景。Redis加载RDB恢复数据远远快于AOF的方式。
> - 缺点：**没办法做到实时持久化/秒级持久化**，属于重量级操作，频繁执行成本过高。
## AOF(append only file)
以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。主要作用是**解决了数据持久化的实时性**
> 重写机制：随着命令不断写入AOF，文件会越来越大，Redis引入AOF重写机制压缩文件体积。(新的文件会去掉浪费空间的冗余命令)
> - 手动触发：直接调用`bgrewriteaof`命令。
> - 自动触发：根据`auto-aof-rewrite-min-size`和`auto-aof-rewrite-percentage`参数确定自动触发时机。
## 缓存设计
缓存可以有效加速应用读写速度(缓存通常都是全内存的(例如:Redis、`Memcache`)，而
存储层查询或者存储会进行I/O操作(例如`MySQL`))，降低后端负载。
### 使用场景
- 1、开销大的复杂计算：一些复杂的操作或者计算（例如大量联表操作、一些分组计算），如果不加缓存，不但无法满足高并发量，同时也会给MySQL带来巨大的负担。
- 2、加速请求响应：如果是高并发场景，有些热点数据需要放到缓存当中，防止经常到数据查询进行IO操作，影响性能
### 缓存更新策略
缓存中的数据会和数据源中的真实数据有一段时间窗口的不一致，需要利用某些策略进行更新
- 1、LRU/LFU/FIFO算法剔除：缓存使用量超过了预设的最大空间，如何对现有的数据进行剔除
- 2、超时剔除：通过给缓存数据设置过期时间。超时剔除通过给缓存数据设置过期时间。一段时间窗口内（取决于过期时间长短）存在一致性问题
- 3、主动更新：应用方对于数据的一致性要求高，需要在真实数据更新后，立即更新缓存数据
### 缓存穿透
查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。
导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义
#### 解决方案
- 缓存空对象：当存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源(可以针对这类数据设置一个较短的过期时间，让其自动剔除)
- 布隆过滤：在访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截器
### 缓存雪崩
由于缓存层承载着大量请求，有效地保护了存储层，但是如果缓存层由于某些原因不能提供服务，于是所有的请
求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。
## 哨兵(Sentinel)
由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，
以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，
自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。
## 集群
分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。
## 底层实现
