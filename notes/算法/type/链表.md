## [删除链表的倒数第 n 个结点](https://leetcode-cn.com/problems/SLwz0R/)
> 采用快慢指针和虚拟头结点
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0),p,q;
        dummy.next = head;
        p = q = dummy;
        //先走 n 个结点
        while(n-- > 0){
            q = q.next;
        }
        while(q.next != null){
            p = p.next;
            q = q.next;
        }
        p.next = p.next.next;
        return dummy.next;
    }
}
```
## * [链表中环的入口节点](https://leetcode-cn.com/problems/c32eOV/)
> 利用快慢指针求出链表中环节点的数目，而后利用双指针求解
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode node = getNode(head);
        if(node == null){
            return null;
        }
        ListNode p = head;
        while(node != p){
            node = node.next;
            p = p.next;
        }
        return node;
    }

    private ListNode getNode(ListNode head){
        if(head == null || head.next == null){
            return null;
        }
        ListNode slow = head.next,fast = slow.next;
        while(fast != null && slow != null){
            if(fast == slow){
                return slow;
            }
            slow = slow.next;
            fast = fast.next;
            if(fast != null){
                fast = fast.next;
            }
        }
        return null;
    }
}
```
## [两个链表的第一个重合节点](https://leetcode-cn.com/problems/3u1WK4/)
> 双指针，交叉遍历
```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA,q = headB;
        while(p != null || q != null){
            if(p == q){
                return p;
            }
            p = p == null ? headB:p.next;
            q = q == null ? headA:q.next;
        }
        return null;
    }
}
```
## [反转链表](https://leetcode-cn.com/problems/UHnkqh/)
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode dummy = new ListNode(0),p = head.next,q;
        head.next = null;
        dummy.next = head;
        while(p != null){
           //保存前置结点
           q = p;
           p = p.next;
           q.next = dummy.next;
           dummy.next = q;
        }
        return dummy.next;
    }
}
```
## [链表中的两数相加](https://leetcode-cn.com/problems/lMSNwu/)
> 链表反转+结点相加
```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        l1 = reverse(l1);
        l2 = reverse(l2);
        if(l1 == null){
            return l2;
        }
        if(l2 == null){
            return l1;
        }
        int carry = 0;
        ListNode dummy = new ListNode();
        ListNode p = dummy;
        while(l1 != null && l2 != null){
            int sum = l1.val + l2.val + carry;
            int val = sum % 10;
            ListNode node = new ListNode(val);
            p.next = node;
            carry = sum/10;
            l1 = l1.next;
            l2 = l2.next;
            p = p.next;
        }
        while(l1 != null){
            int sum = l1.val + carry;
            p.next = new ListNode(sum%10);
            carry = sum/10;
            l1 = l1.next;
            p = p.next;
        }
        while(l2 != null){
            int sum = l2.val + carry;
            p.next = new ListNode(sum%10);
            carry = sum/10;
            l2 = l2.next;
            p = p.next;
        }
        if(carry != 0){
            p.next = new ListNode(carry);
        }
        return reverse(dummy.next);
    }

    private ListNode reverse(ListNode head){
        if(head == null || head.next == null){
            return head;
        }
        ListNode dummy = new ListNode(0),p = head.next,q;
        head.next = null;
        dummy.next = head;
        while(p != null){
           //保存前置结点
           q = p;
           p = p.next;
           q.next = dummy.next;
           dummy.next = q;
        }
        return dummy.next;
    }
}
```
## [回文链表](https://leetcode-cn.com/problems/aMhZSa/)
> 链表反转 + 结点判断，需要注意引用关系，空间复杂度`O(N)`
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode node = reverse(head);
        while(node != null){
            if(node.val != head.val){
                return false;
            }
            node = node.next;
            head = head.next;
        }
        return true;
    }
    private ListNode reverse(ListNode head){
        if(head == null || head.next == null){
            return head;
        }
        ListNode dummy = new ListNode(0),p = head.next,node = new ListNode(head.val);
        node.next = null;
        dummy.next = node;
        while(p != null){
            ListNode q = new ListNode(p.val);
            q.next = dummy.next;
            dummy.next = q;
            p = p.next;
        }
        return dummy.next;
    }
}
```
> 快慢指针+后半段链表反转 
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null){
            return true;
        }
        ListNode dummy = new ListNode(0),fast,slow;
        dummy.next = head;
        fast = slow = dummy;
        while(fast != null){
            slow = slow.next;
            fast = fast.next;
            if(fast != null){
                fast = fast.next;
            }
        }
        System.out.print(slow.val);
        return isPalindrome(head,reverse(slow));
    }

    private boolean isPalindrome(ListNode head,ListNode rev){
        while(rev != null){
            if(rev.val != head.val){
                return false;
            }
            rev = rev.next;
            head = head.next;
        }
        return true;
    }

    private ListNode reverse(ListNode head){
        if(head == null || head.next == null){
            return head;
        }
        ListNode dummy = new ListNode(0),p = head.next,q;
        head.next = null;
        dummy.next = head;
        while(p != null){
           //保存前置结点
           q = p;
           p = p.next;
           q.next = dummy.next;
           dummy.next = q;
        }
        return dummy.next;
    }
}
```
## X[重排链表](https://leetcode-cn.com/problems/LGjMqU/)
> 链表后半段进行反转+两链表重新组合
```java
class Solution {
    public void reorderList(ListNode head) {
        if(head == null || head.next == null){
            return;
        }
        ListNode dummy = new ListNode(0),fast,slow;
        dummy.next = head;
        fast = slow = dummy;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next;
            if(fast.next != null){
                fast = fast.next;
            }
        }
        ListNode temp = slow.next;
        slow.next = null;
        reorderList(head,reverse(temp),dummy);
    }
    //这里需要注意：两个链表如何进行重新组合
    private void reorderList(ListNode head,ListNode rev,ListNode dummy){
        ListNode prev = dummy;
        while(rev != null){
            ListNode temp = head.next;
            prev.next = head;
            head.next = rev;
            prev = rev;
            head = temp;
            rev = rev.next;
        }
        if(head != null){
            prev.next = head;
        }
    }

    private ListNode reverse(ListNode head){
        if(head == null || head.next == null){
            return head;
        }
        ListNode dummy = new ListNode(0),p = head.next,q;
        head.next = null;
        dummy.next = head;
        while(p != null){
            q = p;
            p = p.next;
            q.next = dummy.next;
            dummy.next = q;
        }
        return dummy.next;
    }
}
```
## [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)
```java
class Solution {
    public int[] reversePrint(ListNode head) {
        if(head==null){
            return new int[]{};
        }
        List<Integer> list = reverse(head);
        int len = list.size();
        int[] res = new int[len];
        int j = 0;
        for(int i = len-1;i >= 0;i--){
            res[j++] = list.get(i);
        }
        return res;
    }

    private List<Integer> reverse(ListNode head){
        List<Integer> list = new ArrayList<>();
        while(head != null){
            list.add(head.val);
            head = head.next;
        }
        return list;
    }

}
```
