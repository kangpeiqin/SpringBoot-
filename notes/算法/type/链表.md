## [删除链表的倒数第 n 个结点](https://leetcode-cn.com/problems/SLwz0R/)
> 采用快慢指针和虚拟头结点
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0),p,q;
        dummy.next = head;
        p = q = dummy;
        //先走 n 个结点
        while(n-- > 0){
            q = q.next;
        }
        while(q.next != null){
            p = p.next;
            q = q.next;
        }
        p.next = p.next.next;
        return dummy.next;
    }
}
```
## * [链表中环的入口节点](https://leetcode-cn.com/problems/c32eOV/)
> 利用快慢指针求出链表中环节点的数目，而后利用双指针求解
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode node = getNode(head);
        if(node == null){
            return null;
        }
        ListNode p = head;
        while(node != p){
            node = node.next;
            p = p.next;
        }
        return node;
    }

    private ListNode getNode(ListNode head){
        if(head == null || head.next == null){
            return null;
        }
        ListNode slow = head.next,fast = slow.next;
        while(fast != null && slow != null){
            if(fast == slow){
                return slow;
            }
            slow = slow.next;
            fast = fast.next;
            if(fast != null){
                fast = fast.next;
            }
        }
        return null;
    }
}
```
## [两个链表的第一个重合节点](https://leetcode-cn.com/problems/3u1WK4/)
> 双指针，交叉遍历
```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA,q = headB;
        while(p != null || q != null){
            if(p == q){
                return p;
            }
            p = p == null ? headB:p.next;
            q = q == null ? headA:q.next;
        }
        return null;
    }
}
```
## [反转链表](https://leetcode-cn.com/problems/UHnkqh/)
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode dummy = new ListNode(0),p = head.next,q;
        head.next = null;
        dummy.next = head;
        while(p != null){
           //保存前置结点
           q = p;
           p = p.next;
           q.next = dummy.next;
           dummy.next = q;
        }
        return dummy.next;
    }
}
```
## [链表中的两数相加](https://leetcode-cn.com/problems/lMSNwu/)
```java

```