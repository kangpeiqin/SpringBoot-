## [剑指 Offer II 079. 所有子集](https://leetcode-cn.com/problems/TVdhkn/)
```java
class Solution {
   public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if (nums.length == 0) {
            return res;
        }
        Deque<Integer> subset = new LinkedList<>();
        backtracking(nums, 0, res, subset);
        return res;
    }

    private void backtracking(int[] nums, int deep, List<List<Integer>> res, Deque<Integer> subset) {
        //遍历到根结点，加入结果集合，到达指定的深度
        if (deep == nums.length) {
            res.add(new ArrayList<>(subset));
            return;
        }
        //由于不打算将该数字添加到子集中，因此不对子集进行任何操作，
        // 只需要调用递归函数backtracking处理数组nums中的下一个数字（下标增加1）就可以。
        backtracking(nums, deep + 1, res, subset);
        //考虑将下标为index的数字添加到子集subset的情形
        subset.add(nums[deep]);
        //接下来调用递归函数处理数组nums中的下一个数字（下标增加1）
        backtracking(nums, deep + 1, res, subset);
        //在回溯到父节点之前，应该清除已经对子集状态进行的修改。
        subset.removeLast();
    }
}
```
## [允许重复选择元素的组合](https://leetcode-cn.com/problems/Ygoe9J/)
> 画出决策树
```java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        backtrack(res,new LinkedList<>(),candidates,target,0);
        return res;
    }

    private void backtrack(List<List<Integer>> res,LinkedList<Integer> path,int[] candidates,int target,int index){
        if(target == 0){
            res.add(new LinkedList(path));
            return;
        }
        if(target < 0){
            return;
        }
        for(int i = index; i < candidates.length; i++){
            path.add(candidates[i]);
            backtrack(res,path,candidates,target-candidates[i],i);
            //回溯
            path.removeLast();
        }

    }
}
```