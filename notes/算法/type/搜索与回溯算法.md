## [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)
```java
class Solution {
  public int[] levelOrder(TreeNode root) {
    if (root == null) {
      return new int[]{};
    }
    List<Integer> list = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
      TreeNode node = queue.poll();
      list.add(node.val);
      if (node.left != null) {
        queue.add(node.left);
      }
      if (node.right != null) {
        queue.add(node.right);
      }
    }
    //List转成int数组
    return list.stream().mapToInt(Integer::valueOf).toArray();
  }
}
```
## [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)
```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                //从当前位置进行深度优先遍历
                if(dfs(board,words,i,j,0)){
                    return true;
                }
            }
        }
        return false;
    }
    private boolean dfs(char[][] board,char[] word,int i,int j,int k){
        //边界条件
        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]){
            return false;
        }
        //找到最后一个字符，返回true
        if(k == word.length-1){
            return true;
        }
        //标记被访问
        board[i][j]='\0';
        boolean res = dfs(board,word,i+1,j,k+1) || dfs(board,word,i-1,j,k+1) || 
        dfs(board,word,i,j+1,k+1) || dfs(board,word,i,j-1,k+1);
        //回溯
        board[i][j] = word[k];
        return res;
    }
}
```
## [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)
```java
class Solution {
    public int movingCount(int m, int n, int k) {
        boolean[][] visited = new boolean[m][n];
        return dfs(0, 0, m, n, k, visited);
    }

    private int dfs(int i, int j, int m, int n, int k, boolean[][] visited) {
        if (i >= m || j >= n || (sum(i) + sum(j) > k || visited[i][j])) {
            return 0;
        }
        //标记访问
        visited[i][j] = true;
        //递归进行求解
        return 1 + dfs(i + 1, j, m, n, k, visited) + dfs(i, j + 1, m, n, k, visited);
    }
    private int sum(int num) {
        int sum = 0;
        while (num > 0) {
            sum += num % 10;
            num /= 10;
        }
        return sum;
    }
}
```
## [二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)
```java
class Solution {
    List<List<Integer>> result = new LinkedList<>();

    public List<List<Integer>> pathSum(TreeNode root, int target) {
        LinkedList<Integer> list = new LinkedList<>();
        dfs(root,target,list);
        return result;
    }

    public void dfs(TreeNode root, int target, LinkedList<Integer> list) {
        if (root == null) {
            return;
        }
        //队尾加入
        list.offerLast(root.val);
        if (root.left == null && root.right == null && target == root.val) {
            result.add(new ArrayList<>(list));
        }
        dfs(root.left, target - root.val, list);
        dfs(root.right, target - root.val, list);
        list.removeLast();
    }
}
```
## X[剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)
> 采用中序遍历，在遍历过程中连接各个结点
```java
class Solution {
    private Node head, pre;
    public Node treeToDoublyList(Node root) {
        if(root == null){
            return null;
        }
        inorder(root);
        head.left = pre;
        pre.right = head;
        return head;
    }

    private void inorder(Node root){
        if(root == null){
            return;
        }
        inorder(root.left);
        if(pre != null){
            pre.right = root;
        }else{
            head = root;
        }
        root.left = pre;
        pre = root;
        inorder(root.right);
    }
}
```
## [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)
```java
class Solution {
    private int result,k;
    public int kthLargest(TreeNode root, int k) {
        this.k = k;
        postOrder(root);
        return result;
    }

    private void postOrder(TreeNode root){
        if(root == null){
            return;
        }
        postOrder(root.right);
        k--;
        if(k == 0){
            result = root.val;
        }
        postOrder(root.left);
    } 
}
```
