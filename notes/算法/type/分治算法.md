## X[剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)
> 分治算法，递归求解
```java
class Solution {
    private Map<Integer,Integer> map = new HashMap<>();
    private int[] preorder;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        for(int i = 0;i < inorder.length;i++){
            map.put(inorder[i],i);
        }
        TreeNode root = buildTree(0,0,preorder.length-1);
        return root;
    }
    private TreeNode buildTree(int root,int left,int right){
        if(left > right){
            return null;
        }
        TreeNode node = new TreeNode(preorder[root]);
        //求出左子树的个数
        int index = map.get(preorder[root]);
        //左子树的范围left-index-1
        node.left = buildTree(root+1,left,index-1);
        //右子树的范围
        node.right = buildTree(root+index-left+1,index+1,right);
        return node;
    }
}
```
## X[剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)
> 采用快速幂思想
```java
class Solution {
    public double myPow(double x, int n) {
        if(x == 0){
            return 0;
        }
        long b = n;
        double res = 1.0;
        if(b < 0){
            x = 1/x;
            b = -b;
        }
        while(b > 0){
            if((b&1) == 1){
                res *= x;
            }
            x*=x;
            b >>= 1;
        }
        return res;
    }
}
```
## X[剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)
> 根据二叉搜索树和后序遍历的特点进行求解
```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        return recur(postorder,0,postorder.length-1);
    }

    private boolean recur(int[] postorder,int i,int j){
        if(i >= j){
            return true;
        }
        int p = i;
        while(postorder[p] < postorder[j]){
            p++;
        }
        int m = p;
        while(postorder[p] > postorder[j]){
            p++;
        }
        return p==j && recur(postorder,i,m-1)&&recur(postorder,m,j-1);
    }
}
```
