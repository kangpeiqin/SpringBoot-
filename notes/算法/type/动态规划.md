## [爬楼梯的最少成本](https://leetcode-cn.com/problems/GzCJIP/)
> 动态转移方程 f(i) = min(f(i-1),f(i-2)) + cost[i]，可以从 i-1 到达 i,也可以从 i-2 到达 i
```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[2];
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i = 2; i < cost.length; i++){
            dp[i%2] = Math.min(dp[0],dp[1])+cost[i];
        }
        return Math.min(dp[0],dp[1]);
    }
}
```
## [房屋偷盗](https://leetcode-cn.com/problems/Gu0c2T/)
> 动态转移方程：f(i) = max(f(i-1),f(i-2)+nums[i])
```java
class Solution {
    public int rob(int[] nums) {
        int[] dp = new int[2];
        dp[0] = nums[0];
        if(nums.length >= 2){
            dp[1] = Math.max(nums[0],nums[1]);
        }
        for(int i = 2; i < nums.length; i++){
            dp[i % 2] = Math.max(dp[(i-1)%2],dp[(i-2)%2]+nums[i]);
        }
        return Math.max(dp[0],dp[1]);
    }
}
```
## [环形房屋偷盗](https://leetcode-cn.com/problems/PzWKhm/)
> 从 0 ~ n-2 或者从 1 ~ n-1 进行计算
```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 1){
            return nums[0];
        }
        int len = nums.length;
        return Math.max(rob(nums,0,len-2),rob(nums,1,len-1));
    }
    private int rob(int[] nums,int start,int end){
        int[] dp = new int[2];
        dp[0] = nums[start];
        if(start < end){
            dp[1] = Math.max(nums[start],nums[start + 1]);
        }
        for(int i = start + 2;i <= end; i++){
            int j = i - start;
            dp[j % 2] = Math.max(dp[(j-1)%2],dp[(j-2)%2]+nums[i]);
        }
        return Math.max(dp[0],dp[1]);
    }
}
```