## [爬楼梯的最少成本](https://leetcode-cn.com/problems/GzCJIP/)
> 动态转移方程 f(i) = min(f(i-1),f(i-2)) + cost[i]，可以从 i-1 到达 i,也可以从 i-2 到达 i
```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[2];
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i = 2; i < cost.length; i++){
            dp[i%2] = Math.min(dp[0],dp[1])+cost[i];
        }
        return Math.min(dp[0],dp[1]);
    }
}
```
## [房屋偷盗](https://leetcode-cn.com/problems/Gu0c2T/)
> 动态转移方程：f(i) = max(f(i-1),f(i-2)+nums[i])
```java
class Solution {
    public int rob(int[] nums) {
        int[] dp = new int[2];
        dp[0] = nums[0];
        if(nums.length >= 2){
            dp[1] = Math.max(nums[0],nums[1]);
        }
        for(int i = 2; i < nums.length; i++){
            dp[i % 2] = Math.max(dp[(i-1)%2],dp[(i-2)%2]+nums[i]);
        }
        return Math.max(dp[0],dp[1]);
    }
}
```
## [环形房屋偷盗](https://leetcode-cn.com/problems/PzWKhm/)
> 从 0 ~ n-2 和 1 ~ n-1 进行计算
```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 1){
            return nums[0];
        }
        int len = nums.length;
        return Math.max(rob(nums,0,len-2),rob(nums,1,len-1));
    }
    private int rob(int[] nums,int start,int end){
        int[] dp = new int[2];
        dp[0] = nums[start];
        if(start < end){
            dp[1] = Math.max(nums[start],nums[start + 1]);
        }
        for(int i = start + 2;i <= end; i++){
            int j = i - start;
            dp[j % 2] = Math.max(dp[(j-1)%2],dp[(j-2)%2]+nums[i]);
        }
        return Math.max(dp[0],dp[1]);
    }
}
```
## [粉刷房子](https://leetcode-cn.com/problems/JEj789/)
> 画图，找出动态转移方程
```java
class Solution {
    public int minCost(int[][] costs) {
        int[][] dp = new int[3][costs.length];
        for(int i = 0;i < 3;i++){
            dp[i][0] = costs[0][i];
        }
        for(int i = 1; i < costs.length;i++){
            for(int j = 0; j < 3;j++){
                if(j == 0){
                    dp[j][i] = Math.min(dp[j+1][i-1],dp[j+2][i-1]);
                }else if(j == 1){
                    dp[j][i] = Math.min(dp[j-1][i-1],dp[j+1][i-1]);
                }else{
                    dp[j][i] = Math.min(dp[j-1][i-1],dp[j-2][i-1]);
                }
                dp[j][i] += costs[i][j];
            }
        }
        int len = costs.length - 1;
        return Math.min(dp[0][len],Math.min(dp[1][len],dp[2][len]));
    }
}
```
## X[翻转字符](https://leetcode-cn.com/problems/cyJERH/)
```java
class Solution {
    public int minFlipsMonoIncr(String s) {
        int len = s.length();
        int[][] dp = new int[2][2];
        char ch = s.charAt(0);
        dp[0][0] = ch == '0' ? 0 : 1;
        dp[1][0] = ch == '1' ? 0 : 1;
        for(int i = 1; i < len; i++){
            ch = s.charAt(i);
            int prev0 = dp[0][(i-1)%2];
            int prev1 = dp[1][(i-1)%2];
            dp[0][i%2] = prev0 + (ch == '0' ? 0 : 1);
            dp[1][i%2] = Math.min(prev0, prev1)+(ch == '1' ? 0 : 1);
        }
        return Math.min(dp[0][(len-1)%2],dp[1][(len-1)%2]);
    }
}
```
