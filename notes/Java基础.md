[返回首页](../README.md)

# `Java 基础`
## 类
### 接口
接口声明了一组能力。一个接口可能对应多个实现类。接口方法不需要加修饰符，加与不加相当于都是public abstract。
接口降低了耦合，提高了灵活性。使用接口的代码依赖的是接口本身，而非实现接口的具体类型，程序可以根据情况替换接口的实现，而不影响接口使用者。

> 在Java 8之前，接口中的方法都是抽象方法，都没有实现体，Java 8允许在接口中定义两类新方法：静态方法和默认方法，它们有实现体
### 抽象类
具体类有直接对应的对象，而抽象类没有，它表达的是抽象概念。樱桃是具体对象，而水果则是抽象概念。
抽象方法只有声明，没有实现。接口中不能定义实例变量，而抽象类可以，一个类可以实现多个接口，但只能继承一个类。
#### 应用
**接口声明能力，抽象类提供默认实现**，实现全部或部分方法，一个接口经常有一个对应的抽象类。如`JDK`中`List`接口和对应的`AbstractList`抽象类。对于需要实现接口的具体类而言，有两个选择：一个是实现接口，自己实现全部方法；另一个则是继承抽象类，然后根据需要重写方法。继承的好处是复用代码，只重写需要的部分即可，需要编写的代码比较少，容易实现。不过，如果这个具体类已经有父类了，那就只能选择实现接口了。

### 内部类
内部类与包含它的外部类有比较密切的关系，定义在类内部，可以实现对外部完全隐藏，有更好的封装性。
每个内部类最后都会被编译为一个独立的类，生成一个独立的字节码文件
#### 静态内部类
如果与外部类关系密切，且不依赖于外部类实例，**主要是类内部使用的**，就可以定义为一个静态内部类。则可以考虑定义为静态内部类。它可以访问外部类的静态变量和方法，但不可以访问实例变量和方法。
在`JDK`中使用案例：`Integer：IntegerCache，LinkedList：Node`

#### 成员内部类
与静态内部类不同，除了静态变量和方法，成员内部类还可以直接访问外部类的实例变量和方法
## 集合
Java 集合框架主要包括两种类型的容器，一种是Collection，存储元素集合，另一种是Map，存储键/值对映射。
Collection 接口又有根据容器的不同特点划分出 3 种子类型：List(按照顺序保存元素)、Set(集合：不保存重复的元素) 和 Queue(队列：先进先出)，接下来用抽象类(实现了一些公共的逻辑(设计模式当中的模板模式))，最后是具体实现类。
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d20706cc84b7421daa747c1566bde4a5~tplv-k3u1fbpfcp-watermark.image">

Map 接口有四个主要的实现类：`HashMap`、`HashTable`(线程安全)、`LinkedHashMap`(保存了记录的插入顺序)、`TreeMap`(把它保存的记录根据键排序)

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e777e3b6451b45d8804d0e92e7dd0952~tplv-k3u1fbpfcp-watermark.image">

### `ArrayList` 

### `HashMap`

> 只需要`O(1)`的时间就可以把一个元素存入或读出，根据键快速查找到对应的值。

#### <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">底层原理</a>
> **结构**：数组+链表+红黑树(`JDK1.8`)
>
> **设计实现**：
>
> 1、待存入的元素需要一个能计算自己哈希值的函数(根类：`Object`中的`hashCode`函数)
>
> 2、哈希表根据每个元素的哈希值把它存储到合适的位置，把哈希值转换成数组下标可以采用的方法是对数组的长度求余数。
>
> **哈希冲突**
>
> 如果将两个哈希值不同的元素存入数组中的同一位置，就会引起冲突。为了解决这种冲突，可以把存入数组中同一位置的多个元素用链表存储(**链地址法**)。如果在哈希表中添加更多的元素，那么就会有更多的冲突，有更多的元素被存入同一个链表中，链表越长查找需要的时间就越长，这就违背了设计哈希表的一个初衷：存入和读取一个元素的时间复杂度为O(1)。所以，当哈希表中元素的数目与数组长度的比值超过某一阈值时，就对数组进行**扩容**，把哈希表中的所有的元素重新分配位置。
#### `HashMap`线程安全问题
`HashMap`不是并发安全的，在并发更新的情况下，`HashMap`可能出现死循环，占满CPU。

- <a href="https://coolshell.cn/articles/9606.html">为什么会出现死循环</a>
 > 死循环出现在多个线程同时扩容哈希表的时候
## I/O
I/O本质是将什么样的数据写到什么地方。所以传输数据的格式和传输数据的方式会影响的I/O的效率。Java的I/O操作类在包`java.io`下
### 传输数据的数据格式
- 基于字节：`InputStream`和`OutputStream`
- 基于字符：`Writer`和`Reader`
### 传输数据的方式
- 基于磁盘：`File`
- 基于网络：`Socket`
### 流
流有输入流和输出流之分。输入流就是可以从中获取数据，输入流的实际提供者可以是键盘、文件、网络等；输出流就是可以向其中写入数据，输出流的实际目的地可以是显示终端、文件、网络等。
类`InputStream`表示输入流，`OutputStream`表示输出流，而`FileInputStream`表示文件输入流，`FileOutputStream`表示文件输出流。
- 装饰器模式
> 基本的流按字节读写，没有缓冲区，这不方便使用。引入了很多装饰类，对基本的流增加功能，以方便使用。
### Q&A
#### 为什么有操作字符的I/O接口？
以`InputStream`/`OutputStream`为基类的流基本都是**以二进制形式处理数据的，不能够方便地处理文本文件**，没有编码的概念，能够方便地按字符处理文本数据的基类是Reader和Writer
### 序列化和反序列化
序列化就是将内存中的`Java`对象持久保存到一个流中，反序列化就是从流中恢复`Java`对象到内存。序列化和反序列化主要有两个用处：一是对象状态持久化，二是网络远程调用，用于传递和返回对象。
- Java主要通过接口`Serializable`和类`ObjectInputStream`/`ObjectOutputStream`提供对序列化的支持
- 缺点：列化后的形式比较大、浪费空间，序列化/反序列化的性能也比较低，是Java特有的技术，不能与其他语言交

1、将字段声明为transient，默认序列化机制将忽略该字段，不会进行保存和恢复

2、定义版本号：在序列化时，会将该版本号写入流，在反序列化时，会将流中的值与类定义中的版本号进行比较，如果不匹配，会抛出`InvalidClassException`

- 其他方式：文本格式：`XML`和`JSON`、二进制：`ProtoBuf`、`Thrift`、`MessagePack`
> 更多可以参考<a href="https://www.cyc2018.xyz/Java/Java%20IO.html#%E4%B8%80%E3%80%81%E6%A6%82%E8%A7%88" target="view_window">Java I/O</a>或者<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=io-%e6%b5%81" target="view_window">I/O流</a>
## 静态域与静态方法
- 静态域：static修饰，每个类中只有一个这样的域。属于类(所有的对象共享)，而不属于任何独立的对象。
- 实例域：每一个对象对于所有的实例域都有自己的一份拷贝
- 静态方法：静态方法是一种不能向对象实施操作的方法，可以认为静态方法是没有this参数的方法。使用：(1)一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow）
(2)一个方法只需要访问类的静态域
## 泛型
**类型参数化**，处理的数据类型不是固定的，而是可以作为参数传入。代码与它们能够操作的数据类型不再绑定在一起，同一套代码可以用于多种数据类型
- 作用：复用代码，降低耦合，保证类型安全，泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
- 原理：类型擦除：Java 在编译期间，所有的泛型信息都会被擦掉，替换成Object类型
- 使用：泛型类、泛型接口、泛型方法。
## 并发
线程表示一条单独的执行流，它有自己的程序执行计数器，有自己的栈(虚拟机栈、本地方法栈)。
- 原子变量
> 对于`count++`这种操作来说，使用`synchronized`成本太高了，需要先获取锁，
最后需要释放锁，获取不到锁的情况下需要等待，还会有线程的上下文切换，这些都需要成本。这时候就可以使用原子变量代替。
之所以称为原子变量，是因为它包含一些以原子方式(不可被中断)实现组合操作的方法。主要使用类：`AtomicBoolean`、`AtomicInteger`、`AtomicReference`
> - `compareAndSet(CAS)`：比较并设置，该方法有两个参数`expect`和`update`，以原子方式实现了如下功能：如果当前值等于`expect`，则更新为`update`，否则不更新，如果更新成功，返回`true`，否则返回`false`。
> - 与 `synchronized` 锁相比，原子更新方式代表一种不同的思维方式。synchronized是悲观的，它假定更新很可能冲突，所以先获取锁，得到锁后才更新。原子变量的更新逻辑是乐观的，它假定冲突比较少，但使用CAS更新，也就是进行冲突检测，如果确实冲突了，则继续尝试直到更新完成。
`synchronized`代表一种阻塞式算法，得不到锁的时候，进入锁等待队列，等待其他线程唤醒，有上下文切换开销。原子变量的更新逻辑是非阻塞式的，更新冲突的时候，它就重试，不会阻塞，不会有上下文切换开销。
> - `ABA`问题：假设当前值为A，如果另一个线程先将A修改成B，再修改回成A，当前线程的`CAS`操作无法分辨当前值发生过变化。解决方法是使用`AtomicStampedReference`，在修改值的同时附加一个时间戳，只有值和时间戳都相同才进行修改。
```
实现原理
//声明带有volatile，以保证内存可见性
private volatile int value;
// 原理上，一般的计算机系统都在硬件层次上直接支持CAS指令，而Java的实现都会利用这些特殊指令
unsafe.getAndAddInt(this, valueOffset, 1) + 1;
代码主体是个死循环，先获取当前值current，计算期望的值next，然后调用CAS方法进行更新，
如果更新没有成功，说明value被别的线程改了，则再去取最新值并尝试更新直到成功为止。
```
- 并发容器
> 线程安全的，可以被多个线程并发访问。
> - `CopyOnWriteArrayList`: 适用于读远多于写、集合不太大的场合。锁和循环CAS都是控制对同一个资源的访问冲突，而写时复制通过复制资源减少冲突。
> `CopyOnWriteArrayList`的内部也是一个数组，但这个数组是以原子方式被整体更新的。
### Q&A
#### 为什么调用的是start，执行的却是run方法
`start`表示启动该线程，使其成为一条单独的执行流，操作系统会分配线程相关的资源，每个线程会有单独的程序执行计数器和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行，执行的起点就是`run`方法。
### 线程间的通信
线程间的通信是指线程之间以何种机制来交换信息，Java采用共享内存模型进行通信。
- Java内存模型
> 在Java中，所有**实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享**。
局部变量，方法定义参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。
Java线程之间的通信由Java内存模型（JMM）控制，**JMM决定一个线程对共享变量的写入何时对另一个线程可见**，
JMM定义了线程和主内存之间的抽象关系：**线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本**。一般情况下，线程会先读取/修改本地内存中的变量副本，之后在将值刷到共享内存当中，因此在多线程中可能引起内存可见性问题。
- volatile
> 保证了共享变量的"可见性"。**当一个线程修改一个共享变量时，另外一个线程能够立即读到这个修改的值**。
- synchronized
> Java中的每一个对象都可以作为锁。当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。`synchronized`修饰实例方法，锁是当前的实例对象。
修饰静态方法，锁是当前类的`Class`对象。对于同步方法块，锁是`synchronized`括号当中配置的对象。
> - 实现原理：在JVM中实现，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，`monitorenter`指令是在编译后插入到同步代码块的开始位置，
而`monitorexit`是插入到方法结束处和异常处。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到`monitorenter`
指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。
> - Java对象头：synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头
### 线程池
由于创建/销毁线程需要消耗系统资源，使用线程池可以复用已创建的线程，控制并发的数量。
> 组成：任务队列、工作者线程
- 构造函数参数
> - corePoolSize：核心线程数最大值(核心线程默认情况下会一直存在于线程池中，而非核心线程如果长时间的闲置，就会被销毁)
> - maximumPoolSize：线程总数最大值
> - keepAliveTime：非核心线程闲置超时时长
> - keepAliveTime的单位
> - BlockingQueue：阻塞队列，维护着等待执行的Runnable任务对象。
> - ThreadFactory: 创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数
> - RejectedExecutionHandler：拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略

### AQS(`AbstractQueuedSynchronizer`)：抽象队列同步器
> 抽象类，只实现一些主要逻辑，有些方法由子类实现；实现了同步的功能；使用先进先出（FIFO）队列存储数据。
## 反射
在运行时，而非编译时，动态获取类型的信息，比如接口信息、成员信息、方法信息、构造方法信息等，根据这些动态获取到的信息创建对象、访问/修改成员、调用方法
### Class类
每个已加载的类在内存都有一份类信息，每个对象都有指向它所属类信息的引用。类信息对应的类：`java.lang.Class`，所有类的根父类Object有一个方法，可以获取对象的Class对象
- 根据类名直接加载Class，获取Class对象`Class<?> cls = Class.forName("java.util.HashMap") `
- 通过Class对象可以获取名称信息、字段信息(Field)、方法信息(Method)、创建对象和构造方法(Constructor)、类型信息、声明信息
### 缺点
- 反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，但使用反射，类型是运行时才知道的
- 反射的性能要低一些，在访问字段、调用方法前，反射先要查找对应的Field/Method，要慢一些。
## 注解
注解是给程序添加一些信息，这些信息用于修饰它后面紧挨着的其他代码元素，比如类、接口、字段、方法、方法中的参数、构造方法等。注解可以被编译器、程序运行时和其他工具使用，用于增强或修改程序行为
### 内置注解
@Override、@Deprecated、@SuppressWarnings(都是给编译器用的，所以@Retention都是Retention-Policy.SOURCE)
### 声明式风格
使用声明式风格使得程序员可以在更高的抽象层次上思考和解决问题，而不是陷于底层的细节实现
>声明关键字和语法本身。系统/框架/库，它们负责解释、执行声明式的语句。应用程序，使用声明式风格写程序。
### 注解的创建
- @Target表示注解的目标，如果没有声明@Target，默认为适用于所有类型
- @Retention表示注解信息保留到什么时候
- 注解内参数类型：合法的类型有基本类型、String、Class、枚举、注解，以及这些类型的数组。参数定义时可以使用default指定一个默认值
### 查看注解的信息
@Retention为RetentionPolicy.RUNTIME的注解，可以利用反射机制在运行时进行查看和利用这些信息。
- Class、Field、Method、Constructor类中都有获取注解(getAnnotations、getParameterAnnotations)、判断是否具有指定注解(isAnnotationPresent)的方法
## 类加载
类加载器`ClassLoader`就是加载其他类的类，它负责将字节码文件加载到内存，创建Class对象。
> 每个Class对象都有一个方法(`getClassLoader()`)，可以获取实际加载它的类加载器。如果`ClassLoader`是`Bootstrap ClassLoader`，返回值为`null`。
### 应用场景
> 可以通过`ClassLoader`的`loadClass`或`Class.forName`自己加载类，但什么情况需要自己加载类呢？很多应用使用面向接口的编程，接口具体的实现类可能有很多，适用于不同的场合，具体使用哪个实现类在配置文件中配置，通过更改配置，不用改变代码，就可以改变程序的行为，在设计模式中，这是一种策略模式。
如：`JDBC`数据库驱动的加载(接口与具体的实现分离)。
- 热部署。在不重启应用的情况下，当类的定义即字节码文件修改后，能够替换该`Class`创建的对象。
- 应用的模块化和相互隔离。不同的ClassLoader可以加载相同的类但互相隔离、互不影响。
- 从不同地方灵活加载。系统默认的`ClassLoader`一般从本地的`.class`文件或`jar`文件中加载字节码文件，通过自定义的`ClassLoader`，我们可以从共享的Web服务器、数据库、缓存服务器等其他地方加载字节码文件
### 类加载器种类 
- 引导类加载器（`Bootstrap ClassLoader`）：这个加载器是Java虚拟机实现的一部分，一般是C语言实现的，它负责加载Java的基础类，主要是`<JAVA_HOME>/lib/rt.jar`，日常用的`Java`类库比如`String`、`ArrayList`等都位于该包内
- 扩展类加载器（`Extension ClassLoader`）：这个加载器的实现类是`sun.misc.Laun-cher$ExtClassLoader`，它负责加载Java的一些扩展类，一般是`<JAVA_HOME>/lib/ext`目录中的`jar`包
- 系统类加载器（`Application ClassLoader`）：这个加载器的实现类是`sun.misc. Launcher$AppClassLoader`，它负责加载应用程序的类，包括自己写的和引入的第三方法类库，即所有在类路径中指定的类。
### 类加载的流程
负责加载类的类就是类加载器，它的输入是完全限定的类名，输出是`Class`对象
- 1、判断是否已经加载过了，加载过了，直接返回`Class`对象，一个类只会被一个`Class-Loader`加载一次。
- 2、如果没有被加载，先让父`ClassLoader`去加载，如果加载成功，返回得到的`Class`对象。
- 3、在父`ClassLoader`没有加载成功的前提下，自己尝试加载类。
### Q&A
- “双亲委派”模型
> 优先让父类加载器去加载，可以避免`Java`类库被覆盖的问题。比如，用户程序也定义了一个类`java.lang.String`，通过双亲委派，`java.lang.String`只会被`Bootstrap ClassLoader`加载，避免自定义的`String`覆盖`Java`类库的定义。
## 代理
调用者不直接调用实际对象，而是调用代理对象，由代理对象来访问实际对象，可以在代理类中动态的添加逻辑，如权限控制等。
#### 静态代理
代理类手动创建，一般要实现同一个接口。
#### 动态代理
代理类动态生成
- `JDK`代理
> 代理一组接口，实现公共逻辑。
- `CGLIB`代理
## 正则表达式
正则表达式是一串字符，它描述了一个文本模式，利用它可以方便地处理文本，包括文本的查找、替换、验证、切分等。
正则表达式中的字符有两类：一类是普通字符，就是匹配字符本身；另一类是元字符，这些字符有特殊含义。
正则表达式相关的类位于包`java.util.regex`下。
- `Pattern` & `Matcher`
> `Pattern` 表示正则表达式对象，它与要处理的具体字符串无关。Pattern对象只与正则表达式有关，
与要处理的具体文本无关，它可以安全地被多线程共享，所以，在使用同一个正则表达式处理多个文本时，
应该尽量重用同一个Pattern对象，避免重复编译。
`Matcher`表示一个匹配，它将正则表达式应用于一个具体字符串，通过它对字符串进行处理。
- 匹配模式
> 单行模式（点号模式）、多行模式和大小写无关模式。分别对应
`Pattern.DOTALL`、`Pattern.MULTILINE`和`Pattern.CASE_INSENSI-TIVE`
```
String str = "abc  def      hello.\n   world";
// 1、字符串切分
String[] fields = str.split("[\\s.]+");
------------------------------

String regex = "\\d{8}";
String str = "123456789";
// 2、字符串是否是否匹配给定正则表达式
System.out.println(str.matches(regex));
------------------------------

// 3、根据正则查找匹配的字符串
String regex = "(\\d{4})-(\\d{2})-(\\d{2})";
Pattern pattern = Pattern.compile(regex);
String str = "today is 2022-04-25, yesterday is 2022-04-24";
Matcher matcher = pattern.matcher(str);
// 匹配到的字符
while(matcher.find()){
      //匹配到完整的字符串
     System.out.println("find "+ matcher.group() +" position: "+matcher.start()+"-"+matcher.end());
     //匹配分组
     System.out.println("year:" + matcher.group(1) + ",month:" + matcher.group(2) + ",day:" + matcher.group(3));
}
---------------------------

// 4、替换
String的替换方法：
String regex = "\\s+";
String str = "hello    world       good";
// 替换匹配字符
System.out.println(str.replaceAll(regex, " "));

----------------------
String regex = "(\\d{4})-(\\d{2})-(\\d{2})";
String str = "today is 2017-06-02.";
//可以使用美元符号加数字的形式（比如$1）引用捕获分组，果需要替换为字符'$'本身，需要使用转义。
System.out.println(str.replaceFirst(regex, "$1/$2/$3"));

// 实现简单的模板引擎： "replace {name}, replace {code}.";
// 	{ 是元字符，使用 \ 进行转义
private static Pattern templatePattern = Pattern.compile("\\{(\\w+)\\}");
public static String templateEngine(String template, Map<String, Object> params) {
     StringBuffer sb = new StringBuffer();
     Matcher matcher = templatePattern.matcher(template);
     while (matcher.find()) {
         //查找到匹配的字符
         String key = matcher.group(1);
         Object value = params.get(key);
         matcher.appendReplacement(sb, value != null ?
              Matcher.quoteReplacement(value.toString()) : "");
     }
	 matcher.appendTail(sb);
     return sb.toString();
}
```
### 单个字符
- 特殊字符，比如`tab`字符`\t`、换行符`\n`、回车符`\r`等
- 八进制表示的字符，以`\0`开头
- 十六进制表示的字符，以`\x`开头
- `Unicode`编号表示的字符，以`\u`开头
- 元字符本身，如`．、*、? 、+、\`等，需要在前面加转义字符
### 字符组
包括任意字符、多个指定字符之一、字符区间、排除型字符组、预定义的字符组等。
- `.`是一个元字符(`Pattern.DOTAL`)，默认模式下，它**匹配除了换行符以外的任意字符**
- 匹配组中的任意一个字符，用中括号`[]`表示，为方便表示连续的多个字符，字符组中可以使用连字符`-`。
```
//匹配组中的任意一个字符
[abcd]
//表示匹配一个非数字字符
[^0-9]
```
- 特殊字符
> - `\d`:d表示digit，匹配一个数字字符，等同于`[0-9]`
> - `\w`:w表示word，匹配一个单词字符，等同于`[a-zA-Z_0-9]`
> - `\s`:s表示space，匹配一个空白字符
> - 对应的排除型字符组，用大写表示：`\D`、`\W`、`\S`
> - `^`匹配的是行开始，`$`匹配的是行结束
### 量词
- `+`：表示前面字符的一次或多次出现
- `*`：表示前面字符的零次或多次出现
- `?` ：表示前面字符可能出现，也可能不出现，`{m, n}`：出现次数从m到n
### 分组
表达式可以用括号`()`括起来，表示一个分组，比如a(bc)d, bc就是一个分组。
分组0是一个特殊分组，内容是整个匹配的字符串。

## 函数式编程
`Lambda`表达式：一种紧凑的传递代码的方式。针对常见的集合数据处理，`Java 8`引入了一套新的类库，位于包`java.util.stream`下，称为`Stream API`。

## 参考
- 《Java 编程的逻辑》
- [《深入浅出多线程》](https://redspider.gitbook.io/concurrent)