# 消息中间件
- 简介
> 消息是指在应用间传递的数据。消息中间件是指利用高效可靠的消息传递机制进行与平台无关的数据交流。
> 两种模式：点对点、发布订阅
- 作用
> 流量削峰、系统解耦(消息发布与订阅)、异步通信。
## 生产者
作为消息系统的客户端，生产消息，并投递到消息系统中
## 消费者
从消息系统中获取消息并进行相应的处理
## [RabbitMQ](http://rabbitmq.mr-ping.com/tutorials_with_python/[1]Hello_World.html)
> 一个由 `Erlang` 语言开发的 AMQP 的开源实现。生产者消费者模型，负责接收、存储和转发消息。
### AMQP(高级队列协议)
生产者将消息发送给交换器，交换器和队列绑定，当生产者发送消息时所携带的`RoutingKey`与
`BindingKey` 向匹配时，消息即被存入相应的队列之中。
### 特点
- 可靠性：使用**持久化、传输确认、发布确认**等保证可靠性。
- 灵活的路由：通过 Exchange 来路由消息。
- 消息集群：多个 RabbitMQ 服务器可以组成一个集群
### 交换器(`Exchange`)
生产者先将消息发送到交换器，再由交换器将消息路由到一个或者多个队列当中。在 `RabbitMQ` 中交换器的类型有四种，分别对应不同的路由策略。
- 路由键(`RoutingKey`)
> 生产者者将消息发送给交换器的时候，一般会指定一个路由键，用来指定这个消息路由的规则。
- 绑定(`Binding`)
> **通过绑定将交换器与队列关联起来。在绑定的时候，一般会指定一个绑定键(`BindingKey`)**。这样 `RabbitMQ` 就知道
如何正确地将消息路由到队列了。生产者将消息发送给交换器时，需要一个 `RoutingKey`, 当 `BindingKey` 和
`RoutingKey` 相匹配时，消息就会被路由到相对应的队列当中。一个交换器可以绑定多个队列，`BindingKey` 并不是在所有
情况下都会生效，而是依赖交换器类型。
> - 比喻：交换器相当于投递包裹的邮箱，路由键相当于写在包裹上的地址，绑定键相当于包裹的目的地。当填写在包裹上的地址和实际想要投递的目的地相匹配时，那么这个包裹就会被正确投递到目的地。
#### 交换器类型
- `fanout`
> 把发送到该交换器的消息路由到所有与该交换器绑定的队列当中。
- `direct`
> 把消息路由到那些 `BindingKey` 和 `RoutingKey` 完全匹配的队列当中。
- `topic`
> `RoutingKey` 和 `BingdKey` 做模糊匹配。可以用`*`和`#`做模糊匹配。
- `headers`
> 不依赖于路由键的匹配规则来路由消息。而是根据发送消息中的`headers`属性进行匹配。
### `Connection` 和 `Channel`
无论生产者还是消费者都需要和 `RabbitMQ Broker` 建立连接，这个连接就是一个 `TCP` 连接，也
就是 `Connection`，每个线程把持一个信道 `Connection`，复用了`Connection`的 `TCP` 连接。
### 队列和消息的过期时间(`TTL`)
消息在队列中的生存时间一旦超过设置的过期时间，就会变成死信(Dead Message)，消费者将无法再收到该消息。
- 通过队列属性设置，队列中的所有消息都有相同的过期时间。
- 对消息本身进行单独设置。
> 死信队列：`DLX`(Dead Letter Exchange：死信交换器)。当消息在一个队列中
变成死信之后，它能被重新发送到`DLX`中，`DLX`绑定的队列被称为死信队列。
> - 消息变成死信的情况：1、消息过期，2、队列达到最大长度，3、消息被拒绝。
### 延迟队列
延迟队列存储的消息是对应的延迟消息(当消息被发送后，并不想让消费者立刻拿到消息，而是等待
特定的时间后，消费者才能拿到这个消息进行消费)
- 应用场景
> 订单 30 分钟未支付则进行取消。
### 持久化
可以提高`RabbitMQ`的可靠性，以防在异常情况下(重启、关闭、宕机)下的数据丢失。
> 交换器、队列、消息的持久化
### 消息发送的可靠性
当消息的生产者将消息发送出去后，消息到底有没有正确地到达服务器呢？如果不进行配置，默认情况下生产者不会知道消息是否成功发送服务器。
- 事务机制
- 发送方确认机制
> 生产者将信道设置成 `confirm` 模式，一旦消息被投递到所有匹配的队列后，`RabbitMQ`就会发送
一个确认(`ack`)给生产者，这就使得生产者知晓消息已经正确到达目的地。
### 消息消费
- 推模式(`push`)
> 消息中间件主动将消息推送给消费者，由于推模式是信息到达RabbitMQ后，就会立即被投递给匹配的消费者，
所以实时性非常好，消费者能及时得到最新的消息。
- 拉模式(`pull`)
> 消费者主动从消息中间件拉取消息。拉模式在消费者需要时才去消息中间件拉取消息，这段网络开销会明显增加消息延迟，降低系统吞吐量。
所以实时性较差；消费者难以获取实时消息，具体什么时候能拿到新消息完全取决于消费者什么时候去拉取消息。
### 消息的顺序性
消息的顺序性是指消费者消费到的数据和生产者发布的消息的顺序是一致的。
### `RabbitMQ`的管理
- 多租户与权限h
> 每个 `RabbitMQ` 服务器都能创建虚拟的消息服务器(虚拟主机)，就像虚拟机和物理服务器一样，他们在
各个实例之间提供逻辑的分离，为不同程序安全保密地运行数据，避免队列和交换器命名冲突。
- 用户管理

## Kafka
从数据当中获取信息进行处理分析并获得更多有价值的数据。
分布式流处理平台，支持消息的发布与订阅，支持数据实时处理。
### 基本概念
消息通过主题进行分类，一个主题可以被分为若干个分区。消息以追加的方式写入分区，然后以先进先出的顺序进行读取。
- 主题和分区
> - 消息通过主题进行分类。
> - 一个主题可以包含多个分区，消息被追加写入分区的尾部。通过分区来实现数据冗余和伸缩性。分区可以分布在不同的服务器上。
```text
          主题 "topicName"
分区0：  --------------------     <——
分区1：  -----------------       <—— 消息写入
....    --------------------      <——
```
- 批次
> 属于同一主题和分区的一组消息，可以将消息分成批次传输，较少网络开销。
- 偏移量
> 是一个不断递增的数值，用来区分已经读取过的消息。在给定分区里，每个消息的偏移量都是唯一的。
消费者把每个分区最后读取的消息偏移量保存在 `Zookeeper` 或者 `Kafka` 上，这样如果消费者关闭或者重启，它的读取状态不会丢失。
- `broker`和集群
> 一个独立的`Kafka`服务器被称为`broker`。`broker`接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。
为消费者提供服务，对读取分区的请求作出响应，返回已经提交到磁盘上的消息。
### 数据传递的可靠性
- 保证同一分区消息的顺序

## `Q & A`
### 如何保证消息不丢失
> 分析消息在哪些阶段可能会发生丢失并做出相应的补足措施。 
> - 生产者 --> 消息队列 ---> 消费者
> > - 生产者发送消息到 `Broker`：需要处理好Broker的响应，出错情况下利用重试、报警等手段。
> > - 消费者需要在执行完真正的业务逻辑之后再返回响应给Broker
> 
>影响：可靠性增强，性能下降。
### 如何保证消息的有序性
> - 全局有序：一个生产者+一个消息队列+单线程消费者
> - 局部有序：把消息通过特定的策略发送到固定的队列中，然后每个队列对应一个单线程处理的消费者。
### 重复消息如何处理
> 分析重复消息出现的原因：
> 一般情况下，为了保证消息发送的可靠性，我们发完消息都要等待`Broker`的响应，确认消息是否发送到`Broker`当中，
> 有可能出现`Broker`已经写入消息了，当时响应由于网络原因生产者没有收到，然后生产者又重发了一次，此时消息就重复了。
> - 解决方案
> > 业务上做幂等性处理
### 消息堆积如何处理
> 消息堆积的原因：生产者的生产速度与消费者的消费速度不匹配。

## Reference
[消息中间件选型分析](https://www.infoq.cn/article/kafka-vs-rabbitmq)